   写代码时碰到要弄清楚Oracle的role之间的传递关系,就是有role A的话,可以通过grant A to B,把A赋予给B,又通过grant
 B to C .那我想知道所有role中,有哪些role具有A的权限.
 
   上网一查发现有个递归查询,不过都讲的不是太详细,而那Oracle整的那用法实在太怪异了,跟我们平时用的SQL差的太远,所以
 琢磨了好一阵子脑子才转过弯呢.
 树形结构

可能一看到递归查询这样太专业的名词大家就迷糊了.实际上可以看成有一个树形结构,然后我们要怎么把所有树的所有结点查找出来.学数据结构的时候我们知道要遍历一个树结构有啥前序遍历,中序遍历,后序遍历.反正挺麻烦的.不像遍历个数组那么容易的.那实际上在Oracle的一个表中也可以保存树形结构信息.你要查询所有的树节点,自己整个函数或存储过程去整肯定是超级麻烦的.Oracle提供了一个简单的机制帮助你.要用到start with ...connect by等关键字.先来假定有下面这样一个简单的树形结构存储在表中.
create table Tree(son char(10), father char(10)); 然后插入些信息变成这样的表
 
SON            FATHTER

孙子SB         儿子

孙子NB         儿子

儿子           爸爸

爸爸           爷爷

 
很显然这是一个简单的树形结构

                           孙子SB
                           
                             ^
                             
                             |
                             
爷爷 --> 爸爸 --> 儿子 -->孙子NB

递归查询

假如要查询出以爷爷为根的树的所有节点值咋整呢 ?如果数据少多来几个where嵌套就行.但要是树层次有几百那会搞死人了啊.于是我们就用Oracle提供的递归查询.先看下SQL的写法然后再讲解
SELECT  son FROM tree
START WITH father = '爷爷'
CONNECT BY PRIOR son = father;
返回的结果为 爸爸 儿子 孙子NB 孙子SB
代码看起来很短,但是极为怪异,脑子半天都不容易转过弯呢.实际上我们不把这个SQL语句跟一般的SQL类比,而把它当作给一些函数指定一些参数的赋值语句才更容易理解.
那怎么来理解上面的SQL呢?
首先把SELECT son FROM tree还是看成一般sql一样,就是要查找son这一列的信息.而把以START WITH开头的后面所有东东看成一个where限制条件.其中START WITH 是指定
树的根,这里指定的根是 '爷爷',实际上你还可以指定多个根的,比如 father in ('爷爷', '爸爸') .
而CONNECT BY PRIOR son = father相当于表明在递归的过程中,查找到的树中其它节点接着又作为根结点.然后继续递归. 反正看这sql语句前先想下树形结构,然后想下一般编程语言中的递归函数.再来看时就容易理解点.
